import javax.inject.Inject
import org.apache.groovy.gradle.SharedConfiguration
import org.apache.groovy.gradle.DistributionExtension
import org.apache.groovy.gradle.DocGDK

plugins {
    id 'jvm-ecosystem'
    id 'org.apache.groovy-common'
    id 'org.apache.groovy-aggregating-project'
}

def distributionExtension = project.extensions.create('distribution', DistributionExtension, project)

configurations {
    baseProjects {
        canBeConsumed = false
        canBeResolved = false
    }
    distributions {
        extendsFrom baseProjects
        canBeConsumed = false
        canBeResolved = false
    }
    distributionsRuntimeClasspath {
        canBeConsumed = false
        canBeResolved = true
        extendsFrom distributions
        attributes {
            attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.LIBRARY))
            attribute(Bundling.BUNDLING_ATTRIBUTE, objects.named(Bundling, Bundling.EXTERNAL))
            attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE, objects.named(LibraryElements, LibraryElements.JAR))
            attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_RUNTIME))
        }
    }
    doc
    allJavadoc {
        extendsFrom doc
        canBeConsumed = false
        canBeResolved = true
        attributes {
            attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.DOCUMENTATION))
            attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, DocsType.JAVADOC))
        }
    }
    allGroovydoc {
        extendsFrom doc
        canBeConsumed = false
        canBeResolved = true
        attributes {
            attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.DOCUMENTATION))
            attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, "groovydoc"))
        }
    }
    allAsciidoc {
        extendsFrom baseProjects
        canBeConsumed = false
        canBeResolved = true
        attributes {
            attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.DOCUMENTATION))
            attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, DocsType.USER_MANUAL))
        }
    }
    docgeneratorTool {
        canBeConsumed = false
        canBeResolved = true
        attributes {
            attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.LIBRARY))
            attribute(Bundling.BUNDLING_ATTRIBUTE, objects.named(Bundling, Bundling.EXTERNAL))
            attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE, objects.named(LibraryElements, LibraryElements.JAR))
            attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_RUNTIME))
        }
    }
}

dependencies {
    rootProject.allprojects {
        if (pluginManager.hasPlugin('org.apache.groovy-base')) {
            baseProjects(it)
        }
    }
    // also include optional features from main module
    distributions(project(":")) {
        capabilities {
            requireCapability 'org.apache.groovy:groovy-xstream-ast'
        }
    }
    distributions(project(":")) {
        capabilities {
            requireCapability 'org.apache.groovy:groovy-gpars'
        }
    }
    distributions(project(":")) {
        capabilities {
            requireCapability 'org.apache.groovy:groovy-grapes'
        }
    }
    distributions(project(":")) {
        capabilities {
            requireCapability 'org.apache.groovy:groovy-logging'
        }
    }
    doc project(":groovy-all")
    docgeneratorTool project(":groovy-docgenerator")
}

def docGDK = tasks.register('docGDK', DocGDK) {
    classpath.from configurations.docgeneratorTool
    classes.set(distributionExtension.docgeneratorClasses)
}

tasks.register('distBin', Zip) {
    duplicatesStrategy = DuplicatesStrategy.FAIL
    archiveBaseName = 'apache-groovy'
    into("groovy-${project.version}") {
        with distributionExtension.distSpec
    }
    allprojects {
        if (project.name in ['groovy', 'groovy-test']) {
            distBin.dependsOn(grooidjar)
        }
    }
}

tasks.register("dist", Zip) {
    def groovyBundleVersion = sharedConfiguration.groovyBundleVersion.get()
    description = 'Generates the binary, sources, documentation and full distributions'
    archiveBaseName = 'apache-groovy'
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    archiveClassifier = 'sdk'
    into "groovy-${project.version}"
    from rootProject.file("licenses/LICENSE-SDK")
    from rootProject.file("notices/NOTICE-SDK")
    rename '^([A-Z]+)-([^.]*)', '$1'
    with distributionExtension.distSpec
    into('doc') {
        with distributionExtension.docSpec
    }
    into('src') {
        with distributionExtension.srcSpec
    }
    doFirst {
        def av = project.version
        if ((av.endsWith('SNAPSHOT') && !groovyBundleVersion.endsWith('SNAPSHOT'))
                || (!av.endsWith('SNAPSHOT') && groovyBundleVersion.endsWith('SNAPSHOT'))) {
            throw new GradleException("Incoherent versions. Found groovyVersion=$av and groovyBundleVersion=$groovyBundleVersion")
        }
    }
}

tasks.register('distDoc', Zip) {
    //dependsOn: doc
    archiveBaseName = 'apache-groovy'
    archiveClassifier = 'docs'
    into("groovy-${project.version}") {
        with distributionExtension.docSpec
    }
}

tasks.register('distSrc', Zip) {
    archiveBaseName = 'apache-groovy'
    archiveClassifier = 'src'
    into("groovy-${project.version}")
    with distributionExtension.srcSpec
}

tasks.register("installGroovy", Sync) {
    duplicatesStrategy = DuplicatesStrategy.FAIL
    def installDir = sharedConfiguration.installationDirectory.orElse(project.layout.buildDir.file("install"))
    description 'Generates a groovy distribution into an install directory'
    doLast {
        logger.lifecycle "Groovy installed under ${installDir.get()}"
    }
    with distributionExtension.distSpec
    into installDir
}

tasks.register("doc") {
    dependsOn 'javadocAll', 'groovydocAll', 'docGDK', 'asciidocAll', 'asciidoctorPdf'
}

tasks.register("asciidocAll", Copy) {
    from configurations.allAsciidoc
    into layout.buildDirectory.dir("asciidocAll/html5")
}

interface Services {
    @Inject
    SoftwareComponentFactory getSoftwareComponentFactory()
}

// The Gradle distribution module isn't a Java library
// so we create a custom publication
def factory = objects.newInstance(Services).softwareComponentFactory
def component = factory.adhoc('groovyDistribution')
components.add(component)

def bin = configurations.create("distributionBinary") {
    canBeConsumed = true
    canBeResolved = false
    attributes {
        attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, "application"))
    }
    outgoing {
        artifacts {
            artifact tasks.named('distBin')
        }
    }
}
component.addVariantsFromConfiguration(bin) {
    mapToOptional()
}

def doc = configurations.create("distributionDocs") {
    canBeConsumed = true
    canBeResolved = false
    attributes {
        attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.DOCUMENTATION))
        attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, DocsType.USER_MANUAL))
    }
    outgoing {
        artifacts {
            artifact tasks.named('distDoc')
        }
    }
}
component.addVariantsFromConfiguration(doc) {
    mapToOptional()
}

def src = configurations.create("distributionSources") {
    canBeConsumed = true
    canBeResolved = false
    attributes {
        attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.DOCUMENTATION))
        attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, DocsType.SOURCES))
    }
    outgoing {
        artifacts {
            artifact tasks.named('distSrc')
        }
    }
}
component.addVariantsFromConfiguration(src) {
    mapToOptional()
}

